# Aula de Cria√ß√£o de Classes em Dart

Esta aula tem o objetivo de ensinar a cria√ß√£o de classes em Dart de forma progressiva, considerando que os alunos j√° possuem conhecimento em Java. Utilizaremos o mesmo exemplo em diferentes abordagens para entender melhor as t√©cnicas do Dart.

---

## 1¬∫ Exemplo: Classe `Pessoa` com atributos nulos (`?`)

Neste exemplo, a classe `Pessoa` possui atributos que podem ser nulos, utilizando o operador `?`. Isso √© semelhante ao comportamento das vari√°veis em Java que podem ser nulas.

```dart
import 'dart:io';

void main() {
  // Criando uma inst√¢ncia da classe Pessoa
  Pessoa pessoa = Pessoa();
  
  // Solicitando o nome via console
  print('Digite seu nome:');
  pessoa.nome = stdin.readLineSync(); // L√™ a linha do console e atribui ao nome

  // Solicitando o peso via console
  print('Digite seu peso:');
  pessoa.peso = double.tryParse(stdin.readLineSync() ?? '0'); // L√™ o peso e converte para double

  // Imprimindo os dados da pessoa
  print('Nome: ${pessoa.nome}, Peso: ${pessoa.peso} kg');
}

class Pessoa {
  // Atributos que podem ser nulos, utilizando o operador `?`
  String? nome;
  double? peso;
}
```

### Explica√ß√£o

- **String? nome**: O `?` torna o atributo `nome` opcional, permitindo que ele seja nulo. Isso significa que o valor de `nome` pode ser `null` em vez de ser uma string obrigat√≥ria.
  
- **double? peso**: O mesmo se aplica ao atributo `peso`, que pode ser nulo. Usamos o tipo `double?` para indicar que a vari√°vel pode ou n√£o ter um valor num√©rico.
  
- **stdin.readLineSync()**: Utilizamos este m√©todo para ler entradas do console. Ele l√™ uma linha de texto que o usu√°rio digita e a retorna como uma `String?`. Como o valor pode ser `null`, utilizamos o operador de coalesc√™ncia nula `??` para garantir que, caso n√£o seja fornecida entrada, o valor padr√£o seja uma string vazia.

- **double.tryParse()**: Para garantir que a entrada do usu√°rio seja convertida corretamente em um n√∫mero `double`, usamos `tryParse()`. Isso √© importante porque a convers√£o de uma string para n√∫mero pode falhar, ent√£o essa fun√ß√£o tenta fazer a convers√£o e retorna `null` se n√£o for poss√≠vel. Com isso, garantimos que o valor seja tratado de maneira segura, sem causar erros na execu√ß√£o.

üìå **Documenta√ß√£o Oficial - Null Safety**  
[Link para a documenta√ß√£o oficial](https://dart.dev/null-safety)  

---

## 2¬∫ Exemplo: Uso de late

Aqui utilizamos late para indicar que a vari√°vel ser√° inicializada posteriormente. Com late, o Dart permite que a vari√°vel n√£o seja nula, mas a inicializa√ß√£o pode ser feita mais tarde.

```dart
import 'dart:io';

void main() {
  // Criando uma inst√¢ncia da classe Pessoa
  Pessoa pessoa = Pessoa();
  
  // Solicitando o nome via console
  print('Digite seu nome:');
  pessoa.nome = stdin.readLineSync() ?? ''; // Atribui o nome ap√≥s a leitura

  // Solicitando o peso via console
  print('Digite seu peso:');
  pessoa.peso = double.tryParse(stdin.readLineSync() ?? '0') ?? 0; // Atribui o peso ap√≥s a leitura

  // Imprimindo os dados da pessoa
  print('Nome: ${pessoa.nome}, Peso: ${pessoa.peso} kg');
}

class Pessoa {
  // Atributos com `late` indicando que ser√£o inicializados posteriormente
  late String nome;
  late double peso;
}
```
### Explica√ß√£o

- **`late`**: O modificador `late` permite declarar vari√°veis **n√£o nulas** sem a necessidade de inicializ√°-las imediatamente. Ele informa ao Dart que a vari√°vel ser√° inicializada em algum momento antes de ser acessada, mas voc√™ n√£o precisa fornecer um valor na declara√ß√£o.

- **Cuidado com o uso de `late`**: Se voc√™ tentar acessar uma vari√°vel `late` sem inicializ√°-la primeiro, ocorrer√° um **erro de execu√ß√£o**. Isso acontece porque o Dart n√£o consegue garantir que o valor da vari√°vel foi atribu√≠do antes de seu uso, o que pode resultar em comportamento indesejado na aplica√ß√£o.

- **Uso inadequado do `late`**: O uso inadequado anula o principal benef√≠cio do null safery, que √© a indica√ß√£o do erro em tempo de compila√ß√£o.

üìå **Documenta√ß√£o Oficial - `late`**  
[Link para a documenta√ß√£o oficial](https://dart.dev/guides/language/language-tour#late-variables)

---

## 3¬∫ Exemplo: Inicializa√ß√£o via Construtor (Par√¢metros Posicionais)
Agora, usaremos um construtor para garantir que os atributos sejam inicializados corretamente ao criar a inst√¢ncia da classe. Isso elimina a possibilidade de valores nulos ou n√£o inicializados.

```dart
import 'dart:io';

void main() {
  // Solicitando o nome via console
  print('Digite seu nome:');
  String nome = stdin.readLineSync() ?? ''; // L√™ o nome

  // Solicitando o peso via console
  print('Digite seu peso:');
  double peso = double.tryParse(stdin.readLineSync() ?? '0') ?? 0; // L√™ e converte o peso para double

  // Criando a inst√¢ncia da classe Pessoa com par√¢metros posicionais
  Pessoa pessoa = Pessoa(nome, peso);

  // Imprimindo os dados da pessoa
  print('Nome: ${pessoa.nome}, Peso: ${pessoa.peso} kg');
}

class Pessoa {
  // Atributos obrigat√≥rios no construtor
  String nome;
  double peso;

  // Construtor que inicializa os atributos
  Pessoa(this.nome, this.peso);
}
```
### Explica√ß√£o

- **Construtor Pessoa(this.nome, this.peso)**: Usamos esse construtor para inicializar os atributos da classe `Pessoa` logo ao criar o objeto. O modificador `this` permite que os par√¢metros do construtor sejam atribu√≠dos diretamente aos atributos da classe.

- **Vantagem**: Ao usar esse tipo de construtor, o Dart garante que os valores dos atributos sejam sempre inicializados corretamente no momento da cria√ß√£o da inst√¢ncia da classe, evitando a possibilidade de atribui√ß√µes nulas ou incorretas.

üìå **Documenta√ß√£o Oficial - Construtores**  
[Link para a documenta√ß√£o oficial](https://dart.dev/guides/language/language-tour#constructors)

---

## 4¬∫ Exemplo: Construtor com Par√¢metros Nomeados

Agora, utilizamos par√¢metros nomeados no construtor, o que melhora a legibilidade do c√≥digo. Par√¢metros nomeados s√£o especialmente √∫teis quando se tem muitos par√¢metros em um construtor.

```dart
import 'dart:io';

void main() {
  // Solicitando o nome via console
  print('Digite seu nome:');
  String nome = stdin.readLineSync() ?? ''; // L√™ o nome

  // Solicitando o peso via console
  print('Digite seu peso:');
  double peso = double.tryParse(stdin.readLineSync() ?? '0') ?? 0; // L√™ e converte o peso para double

  // Criando a inst√¢ncia da classe Pessoa com par√¢metros nomeados
  Pessoa pessoa = Pessoa(nome: nome, peso: peso);

  // Imprimindo os dados da pessoa
  print('Nome: ${pessoa.nome}, Peso: ${pessoa.peso} kg');
}

class Pessoa {
  // Atributos obrigat√≥rios no construtor com par√¢metros nomeados
  String nome;
  double peso;

  // Construtor com par√¢metros nomeados
  Pessoa({required this.nome, required this.peso});
}
```
### Explica√ß√£o

- **Par√¢metros nomeados - Vantagem**: O uso de par√¢metros nomeados torna o c√≥digo mais leg√≠vel, especialmente quando a classe possui muitos atributos. Dessa forma, fica claro quais valores est√£o sendo atribu√≠dos a quais atributos.

- **required**: O modificador `required` √© utilizado para garantir que os par√¢metros nomeados sejam passados obrigatoriamente ao instanciar o objeto. Isso evita que o construtor seja chamado sem os dados necess√°rios para a cria√ß√£o do objeto.


üìå **Documenta√ß√£o Oficial - Par√¢metros Nomeados**  
[Link para a documenta√ß√£o oficial](https://dart.dev/guides/language/language-tour#named-parameters)


---

## 5¬∫ Exemplo: Uso de get e set para Valida√ß√£o

Agora, vamos incluir m√©todos get e set para validar os dados antes de modificar os atributos da classe.

```dart
import 'dart:io';

void main() {
  // Solicitando o nome via console
  print('Digite seu nome:');
  String nome = stdin.readLineSync() ?? ''; // L√™ o nome

  // Solicitando o peso via console
  print('Digite seu peso:');
  double peso = double.tryParse(stdin.readLineSync() ?? '0') ?? 0; // L√™ e converte o peso para double

  // Criando a inst√¢ncia da classe Pessoa com par√¢metros nomeados
  Pessoa pessoa = Pessoa(nome: nome, peso: peso);

  // Imprimindo os dados da pessoa
  print('Nome: ${pessoa.nome}, Peso: ${pessoa.peso} kg');
}

class Pessoa {
  // Atributos privados para encapsulamento
  String _nome;
  double _peso;

  // Construtor com par√¢metros nomeados
  Pessoa({required String nome, required double peso}) : _nome = nome, _peso = peso;

  // Getter para acessar o nome
  String get nome => _nome;

  // Setter para modificar o nome
  set nome(String novoNome) {
    if (novoNome.isNotEmpty) {
      _nome = novoNome; // Se o nome n√£o for vazio, atribui o novo valor
    } else {
      throw Exception('Nome inv√°lido!'); // Se o nome for vazio, exibe um erro
    }
  }

  // Getter para acessar o peso
  double get peso => _peso;

  // Setter para modificar o peso com valida√ß√£o
  set peso(double novoPeso) {
    if (novoPeso > 0) {
      _peso = novoPeso; // Se o peso for v√°lido, atribui o valor
    } else {
      throw Exception('Peso inv√°lido!'); // Se o peso for inv√°lido, exibe um erro
    }
  }
}
```
### Explica√ß√£o

- **_peso**: O atributo `_peso` √© declarado como privado, o que significa que n√£o pode ser acessado diretamente fora da classe. Ele √© acessado por meio de um *getter* e um *setter*.

- **Set**: O *setter* √© utilizado para realizar uma valida√ß√£o antes de definir o valor do atributo. Neste caso, o *setter* garante que o peso seja sempre positivo antes de ser atribu√≠do ao atributo `_peso`.

üìå **Documenta√ß√£o Oficial - Getters e Setters**  
[Link para a documenta√ß√£o oficial](https://dart.dev/guides/language/language-tour#getters-and-setters)

---

## 6¬∫ Exemplo: Par√¢metro do tipo fun√ß√£o no construtor

Podemos definir um par√¢metro do tipo fun√ß√£o no construtor. Neste exemplo, criamos a classe Pessoa com os atributos nome, peso e altura, al√©m de um par√¢metro do tipo fun√ß√£o chamado calcularIMC, que calcula o √çndice de Massa Corporal (IMC).

```dart
class Pessoa {
  String nome;
  double peso;
  double altura;
  double Function(double, double) calcularIMC; // Par√¢metro do tipo fun√ß√£o

  Pessoa(this.nome, this.peso, this.altura, this.calcularIMC);
}

double calcularIMCFunc(double peso, double altura) {
  return peso / (altura * altura);
}

void main() {
  Pessoa pessoa = Pessoa("Carlos", 80.0, 1.75, calcularIMCFunc);

  print("Nome: ${pessoa.nome}");
  print("IMC: ${pessoa.calcularIMC(pessoa.peso, pessoa.altura)}");
}

```

### üìñ Explica√ß√£o:

Criamos a classe Pessoa com um par√¢metro de fun√ß√£o calcularIMC.

Definimos uma fun√ß√£o nomeada calcularIMCFunc que calcula o IMC.

Passamos essa fun√ß√£o como argumento na inst√¢ncia da classe Pessoa.

No main(), chamamos a fun√ß√£o armazenada no objeto para calcular o IMC.

üìå Mais sobre fun√ß√µes em Dart: [Fun√ß√µes no Dart](https://dart.dev/language/functions)

---

## 7¬∫ Exemplo: Fun√ß√£o an√¥nima como par√¢metro

A diferen√ßa para o exemplo anterior √© que agora passamos uma fun√ß√£o an√¥nima diretamente no construtor, sem criar uma fun√ß√£o nomeada separada.

```dart
class Pessoa {
  String nome;
  double peso;
  double altura;
  double Function(double, double) calcularIMC; // Par√¢metro do tipo fun√ß√£o

  Pessoa(this.nome, this.peso, this.altura, this.calcularIMC);
}

void main() {
  Pessoa pessoa = Pessoa(
    "Carlos",
    80.0,
    1.75,
    (peso, altura) => peso / (altura * altura), // Fun√ß√£o an√¥nima
  );

  print("Nome: ${pessoa.nome}");
  print("IMC: ${pessoa.calcularIMC(pessoa.peso, pessoa.altura)}");
}

```
### üìñ Explica√ß√£o:
A fun√ß√£o an√¥nima (peso, altura) => peso / (altura * altura) √© passada diretamente no construtor.

Isso elimina a necessidade de criar uma fun√ß√£o nomeada separadamente.

üìå Mais sobre fun√ß√µes an√¥nimas em Dart: [Fun√ß√µes an√¥nimas](https://dart.dev/language/functions#anonymous-functions)

---

##  8¬∫ Exemplo: Associa√ß√£o entre classes (inst√¢ncia com refer√™ncia)

Agora, al√©m do par√¢metro do tipo fun√ß√£o, introduzimos a associa√ß√£o de classes. Criamos a classe Cidade e a associamos √† Pessoa, representando a cidade onde a pessoa mora.

```dart
class Cidade {
  String nome;
  String estado;

  Cidade(this.nome, this.estado);
}

class Pessoa {
  String nome;
  double peso;
  double altura;
  double Function(double, double) calcularIMC;
  Cidade cidade; // Associa√ß√£o com a classe Cidade

  Pessoa(this.nome, this.peso, this.altura, this.calcularIMC, this.cidade);
}

void main() {
  var cidadeNatal = Cidade("S√£o Paulo", "SP"); // Inst√¢ncia com refer√™ncia
  var pessoa = Pessoa(
    "Carlos",
    80.0,
    1.75,
    (peso, altura) => peso / (altura * altura),
    cidadeNatal,
  );

  print("Nome: ${pessoa.nome}");
  print("Cidade: ${pessoa.cidade.nome}, ${pessoa.cidade.estado}");
  print("IMC: ${pessoa.calcularIMC(pessoa.peso, pessoa.altura)}");
}
```

### üìñ Explica√ß√£o:

Criamos a classe Cidade, que representa a cidade onde a pessoa mora.

Na classe Pessoa, adicionamos um atributo cidade que recebe um objeto da classe Cidade.

No main(), primeiro criamos uma inst√¢ncia de Cidade e depois passamos essa refer√™ncia ao instanciar Pessoa.

üìå Mais sobre classes e objetos em Dart: [Classes no Dart](https://dart.dev/language/classes)

---

## 9¬∫ Exemplo: Inst√¢ncia an√¥nima na associa√ß√£o

Agora, em vez de criar uma vari√°vel separada para Cidade, instanciamos a cidade diretamente no construtor da Pessoa (inst√¢ncia an√¥nima).


```dart
class Cidade {
  String nome;
  String estado;

  Cidade(this.nome, this.estado);
}

class Pessoa {
  String nome;
  double peso;
  double altura;
  double Function(double, double) calcularIMC;
  Cidade cidade; // Associa√ß√£o com a classe Cidade

  Pessoa(this.nome, this.peso, this.altura, this.calcularIMC, this.cidade);
}

void main() {
  var pessoa = Pessoa(
    "Carlos",
    80.0,
    1.75,
    (peso, altura) => peso / (altura * altura),
    Cidade("S√£o Paulo", "SP"), // Inst√¢ncia an√¥nima de Cidade
  );

  print("Nome: ${pessoa.nome}");
  print("Cidade: ${pessoa.cidade.nome}, ${pessoa.cidade.estado}");
  print("IMC: ${pessoa.calcularIMC(pessoa.peso, pessoa.altura)}");
}
```

### üìñ Explica√ß√£o:

Em vez de armazenar a cidade em uma vari√°vel, instanciamos Cidade diretamente no construtor de Pessoa.

Isso torna o c√≥digo mais abreviado quando a cidade n√£o precisa ser reutilizada em outros lugares.

üìå Mais sobre inst√¢ncias e construtores: [Construtores no Dart](https://dart.dev/language/constructors)

### üìå Resumo das diferen√ßas entre os exemplos

Exemplo	Diferen√ßa principal

- 6¬∫	Fun√ß√£o nomeada como par√¢metro do construtor
- 7¬∫	Fun√ß√£o an√¥nima como par√¢metro do construtor
- 8¬∫	Associa√ß√£o entre classes com inst√¢ncia por refer√™ncia
- 9¬∫	Associa√ß√£o entre classes com inst√¢ncia an√¥nima

